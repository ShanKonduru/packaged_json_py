{
  "name": ".",
  "type": "directory",
  "path": "C:\\packaged_json",
  "generated_at": "2025-10-06T08:09:59.690064",
  "contents": [
    {
      "name": "test_folder",
      "type": "directory",
      "contents": [
        {
          "name": "subdir1",
          "type": "directory",
          "contents": [
            {
              "name": "nested",
              "type": "directory",
              "contents": [
                {
                  "name": "file3.txt",
                  "type": "file",
                  "size": 28,
                  "modified": "2025-10-06T07:56:22.222903",
                  "extension": ".txt",
                  "contents": {
                    "type": "text",
                    "encoding": "latin-1",
                    "data": "ÿþN\u0000e\u0000s\u0000t\u0000e\u0000d\u0000 \u0000f\u0000i\u0000l\u0000e\u0000\n\u0000\n\u0000"
                  }
                }
              ]
            },
            {
              "name": "file2.txt",
              "type": "file",
              "size": 30,
              "modified": "2025-10-06T07:56:22.220942",
              "extension": ".txt",
              "contents": {
                "type": "text",
                "encoding": "latin-1",
                "data": "ÿþA\u0000n\u0000o\u0000t\u0000h\u0000e\u0000r\u0000 \u0000f\u0000i\u0000l\u0000e\u0000\n\u0000\n\u0000"
              }
            }
          ]
        },
        {
          "name": "subdir2",
          "type": "directory",
          "contents": []
        },
        {
          "name": "file1.txt",
          "type": "file",
          "size": 30,
          "modified": "2025-10-06T07:56:22.217181",
          "extension": ".txt",
          "contents": {
            "type": "text",
            "encoding": "latin-1",
            "data": "ÿþT\u0000e\u0000s\u0000t\u0000 \u0000c\u0000o\u0000n\u0000t\u0000e\u0000n\u0000t\u0000\n\u0000\n\u0000"
          }
        },
        {
          "name": "hello.py",
          "type": "file",
          "size": 60,
          "modified": "2025-10-06T08:02:34.797184",
          "extension": ".py",
          "contents": {
            "type": "text",
            "encoding": "latin-1",
            "data": "ÿþp\u0000r\u0000i\u0000n\u0000t\u0000(\u0000\"\u0000H\u0000e\u0000l\u0000l\u0000o\u0000 \u0000f\u0000r\u0000o\u0000m\u0000 \u0000P\u0000y\u0000t\u0000h\u0000o\u0000n\u0000!\u0000\"\u0000)\u0000\n\u0000\n\u0000"
          }
        }
      ]
    },
    {
      "name": "config.json",
      "type": "file",
      "size": 1667,
      "modified": "2025-10-06T08:07:21.460868",
      "extension": ".json",
      "contents": {
        "type": "text",
        "encoding": "utf-8",
        "data": "{\n  \"capture_contents\": true,\n  \"max_content_size\": 10485760,\n  \"capture_extensions\": [],\n  \"no_capture_extensions\": [\n    \".exe\",\n    \".dll\",\n    \".so\",\n    \".dylib\",\n    \".bin\",\n    \".img\",\n    \".iso\",\n    \".zip\",\n    \".rar\",\n    \".7z\",\n    \".tar\",\n    \".gz\",\n    \".bz2\",\n    \".xz\",\n    \".pdf\",\n    \".doc\",\n    \".docx\",\n    \".xls\",\n    \".xlsx\",\n    \".ppt\",\n    \".pptx\",\n    \".mp3\",\n    \".mp4\",\n    \".avi\",\n    \".mkv\",\n    \".wav\",\n    \".flac\",\n    \".jpg\",\n    \".jpeg\",\n    \".png\",\n    \".gif\",\n    \".bmp\",\n    \".tiff\",\n    \".webp\",\n    \".ico\"\n  ],\n  \"ignore_extensions\": [\n    \".pyc\",\n    \".pyo\",\n    \".pyd\",\n    \".so\",\n    \".dll\",\n    \".dylib\",\n    \".o\",\n    \".obj\",\n    \".exe\",\n    \".bin\",\n    \".log\",\n    \".tmp\",\n    \".temp\",\n    \".cache\",\n    \".bak\",\n    \".swp\",\n    \".swo\",\n    \"~\",\n    \".DS_Store\",\n    \"Thumbs.db\"\n  ],\n  \"ignore_file_patterns\": [\n    \"*.tmp\",\n    \"*.temp\",\n    \"*.log\",\n    \"*.cache\",\n    \"*.bak\",\n    \".*\",\n    \"#*#\",\n    \"*~\"\n  ],\n  \"ignore_folder_patterns\": [\n    \"__pycache__\",\n    \"*.egg-info\",\n    \".git\",\n    \".svn\",\n    \".hg\",\n    \".bzr\",\n    \"CVS\",\n    \".vscode\",\n    \".idea\",\n    \"node_modules\",\n    \"venv\",\n    \"env\",\n    \".env\",\n    \"virtualenv\",\n    \".venv\",\n    \"build\",\n    \"dist\",\n    \"target\",\n    \"bin\",\n    \"obj\",\n    \".pytest_cache\",\n    \".coverage\",\n    \".tox\",\n    \".mypy_cache\",\n    \"outputs\"\n  ],\n  \"ignore_paths\": [\n    \".gitignore\",\n    \".gitattributes\",\n    \"LICENSE\",\n    \"README.md\",\n    \"requirements.txt\",\n    \"setup.py\",\n    \"setup.cfg\",\n    \"pyproject.toml\",\n    \"Pipfile\",\n    \"Pipfile.lock\"\n  ]\n}"
      }
    },
    {
      "name": "config_manager.py",
      "type": "file",
      "size": 7791,
      "modified": "2025-10-06T08:07:21.460868",
      "extension": ".py",
      "contents": {
        "type": "text",
        "encoding": "utf-8",
        "data": "\"\"\"\nConfiguration Manager - Handles loading and validation of configuration files.\n\"\"\"\n\nimport json\nfrom pathlib import Path\nfrom typing import Dict, Any\n\n\nclass ConfigManager:\n    \"\"\"Manages configuration file loading and validation.\"\"\"\n    \n    def __init__(self, config_path: str):\n        \"\"\"\n        Initialize the ConfigManager.\n        \n        Args:\n            config_path: Path to the configuration file\n        \"\"\"\n        self.config_path = Path(config_path)\n        self.default_config = self._get_default_config()\n    \n    def _get_default_config(self) -> Dict[str, Any]:\n        \"\"\"\n        Get the default configuration.\n        \n        Returns:\n            Default configuration dictionary\n        \"\"\"\n        return {\n            \"capture_contents\": True,\n            \"max_content_size\": 10485760,\n            \"capture_extensions\": [],\n            \"no_capture_extensions\": [\n                \".exe\",\n                \".dll\",\n                \".so\",\n                \".dylib\",\n                \".bin\",\n                \".img\",\n                \".iso\",\n                \".zip\",\n                \".rar\",\n                \".7z\",\n                \".tar\",\n                \".gz\",\n                \".bz2\",\n                \".xz\",\n                \".pdf\",\n                \".doc\",\n                \".docx\",\n                \".xls\",\n                \".xlsx\",\n                \".ppt\",\n                \".pptx\",\n                \".mp3\",\n                \".mp4\",\n                \".avi\",\n                \".mkv\",\n                \".wav\",\n                \".flac\",\n                \".jpg\",\n                \".jpeg\",\n                \".png\",\n                \".gif\",\n                \".bmp\",\n                \".tiff\",\n                \".webp\",\n                \".ico\"\n            ],\n            \"ignore_extensions\": [\n                \".pyc\",\n                \".pyo\",\n                \".pyd\",\n                \".so\",\n                \".dll\",\n                \".dylib\",\n                \".o\",\n                \".obj\",\n                \".exe\",\n                \".bin\",\n                \".log\",\n                \".tmp\",\n                \".temp\",\n                \".cache\",\n                \".bak\",\n                \".swp\",\n                \".swo\",\n                \"~\",\n                \".DS_Store\",\n                \"Thumbs.db\"\n            ],\n            \"ignore_file_patterns\": [\n                \"*.tmp\",\n                \"*.temp\",\n                \"*.log\",\n                \"*.cache\",\n                \"*.bak\",\n                \".*\",\n                \"#*#\",\n                \"*~\"\n            ],\n            \"ignore_folder_patterns\": [\n                \"__pycache__\",\n                \"*.egg-info\",\n                \".git\",\n                \".svn\",\n                \".hg\",\n                \".bzr\",\n                \"CVS\",\n                \".vscode\",\n                \".idea\",\n                \"node_modules\",\n                \"venv\",\n                \"env\",\n                \".env\",\n                \"virtualenv\",\n                \".venv\",\n                \"build\",\n                \"dist\",\n                \"target\",\n                \"bin\",\n                \"obj\",\n                \".pytest_cache\",\n                \".coverage\",\n                \".tox\",\n                \".mypy_cache\",\n                \"outputs\"\n            ],\n            \"ignore_paths\": [\n                \".gitignore\",\n                \".gitattributes\",\n                \"LICENSE\",\n                \"README.md\",\n                \"requirements.txt\",\n                \"setup.py\",\n                \"setup.cfg\",\n                \"pyproject.toml\",\n                \"Pipfile\",\n                \"Pipfile.lock\"\n            ]\n        }\n    \n    def load_config(self) -> Dict[str, Any]:\n        \"\"\"\n        Load configuration from file or create default if not exists.\n        \n        Returns:\n            Configuration dictionary\n            \n        Raises:\n            json.JSONDecodeError: If config file contains invalid JSON\n            FileNotFoundError: If config file doesn't exist and can't be created\n        \"\"\"\n        if not self.config_path.exists():\n            # Create default config file\n            self._create_default_config()\n            return self.default_config.copy()\n        \n        try:\n            with open(self.config_path, 'r', encoding='utf-8') as f:\n                config = json.load(f)\n            \n            # Validate and merge with defaults\n            return self._validate_and_merge_config(config)\n        \n        except json.JSONDecodeError as e:\n            raise json.JSONDecodeError(\n                f\"Invalid JSON in config file '{self.config_path}': {e.msg}\",\n                e.doc,\n                e.pos\n            )\n        except Exception as e:\n            raise FileNotFoundError(f\"Error reading config file '{self.config_path}': {e}\")\n    \n    def _create_default_config(self) -> None:\n        \"\"\"\n        Create a default configuration file.\n        \n        Raises:\n            Exception: If unable to create the config file\n        \"\"\"\n        try:\n            with open(self.config_path, 'w', encoding='utf-8') as f:\n                json.dump(self.default_config, f, indent=2, ensure_ascii=False)\n        except Exception as e:\n            raise Exception(f\"Failed to create default config file '{self.config_path}': {e}\")\n    \n    def _validate_and_merge_config(self, config: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        Validate loaded configuration and merge with defaults.\n        \n        Args:\n            config: Loaded configuration dictionary\n            \n        Returns:\n            Validated and merged configuration\n        \"\"\"\n        # Start with default config\n        merged_config = self.default_config.copy()\n        \n        # Validate and merge boolean options\n        for key in ['capture_contents']:\n            if key in config:\n                if isinstance(config[key], bool):\n                    merged_config[key] = config[key]\n                else:\n                    print(f\"Warning: '{key}' in config should be a boolean, using default\")\n        \n        # Validate and merge integer options\n        for key in ['max_content_size']:\n            if key in config:\n                if isinstance(config[key], int) and config[key] > 0:\n                    merged_config[key] = config[key]\n                else:\n                    print(f\"Warning: '{key}' in config should be a positive integer, using default\")\n        \n        # Validate and merge list options\n        for key in ['ignore_extensions', 'ignore_file_patterns', \n                   'ignore_folder_patterns', 'ignore_paths',\n                   'capture_extensions', 'no_capture_extensions']:\n            if key in config:\n                if isinstance(config[key], list):\n                    # If user provided this section, use it (don't merge with defaults)\n                    merged_config[key] = config[key]\n                else:\n                    print(f\"Warning: '{key}' in config should be a list, using default\")\n        \n        return merged_config\n    \n    def save_config(self, config: Dict[str, Any]) -> None:\n        \"\"\"\n        Save configuration to file.\n        \n        Args:\n            config: Configuration dictionary to save\n            \n        Raises:\n            Exception: If unable to save the config file\n        \"\"\"\n        try:\n            with open(self.config_path, 'w', encoding='utf-8') as f:\n                json.dump(config, f, indent=2, ensure_ascii=False)\n        except Exception as e:\n            raise Exception(f\"Failed to save config file '{self.config_path}': {e}\")"
      }
    },
    {
      "name": "directory_packager.py",
      "type": "file",
      "size": 11835,
      "modified": "2025-10-06T08:02:59.788300",
      "extension": ".py",
      "contents": {
        "type": "text",
        "encoding": "utf-8",
        "data": "\"\"\"\nDirectory Packager - Core functionality for scanning directories and generating JSON.\n\"\"\"\n\nimport json\nimport os\nimport base64\nfrom pathlib import Path\nfrom typing import Dict, List, Any, Optional\nimport fnmatch\nfrom datetime import datetime\n\n\nclass DirectoryPackager:\n    \"\"\"Handles directory scanning and JSON generation with configurable ignore patterns.\"\"\"\n    \n    def __init__(self, config: Dict[str, Any], verbose: bool = False):\n        \"\"\"\n        Initialize the DirectoryPackager.\n        \n        Args:\n            config: Configuration dictionary with ignore patterns\n            verbose: Enable verbose output\n        \"\"\"\n        self.config = config\n        self.verbose = verbose\n        self.stats = {\n            'directories': 0,\n            'files': 0,\n            'ignored': 0\n        }\n    \n    def should_ignore(self, path: Path) -> bool:\n        \"\"\"\n        Check if a path should be ignored based on configuration patterns.\n        \n        Args:\n            path: Path to check\n            \n        Returns:\n            True if the path should be ignored, False otherwise\n        \"\"\"\n        name = path.name\n        \n        # Check ignored file extensions\n        if path.is_file():\n            for ext in self.config.get('ignore_extensions', []):\n                if name.lower().endswith(ext.lower()):\n                    if self.verbose:\n                        print(f\"Ignoring file (extension): {path}\")\n                    return True\n        \n        # Check ignored file patterns\n        for pattern in self.config.get('ignore_file_patterns', []):\n            if fnmatch.fnmatch(name, pattern):\n                if self.verbose:\n                    print(f\"Ignoring (file pattern): {path}\")\n                return True\n        \n        # Check ignored folder patterns\n        if path.is_dir():\n            for pattern in self.config.get('ignore_folder_patterns', []):\n                if fnmatch.fnmatch(name, pattern):\n                    if self.verbose:\n                        print(f\"Ignoring folder: {path}\")\n                    return True\n        \n        # Check ignored paths (exact matches)\n        for ignored_path in self.config.get('ignore_paths', []):\n            if str(path).endswith(ignored_path) or name == ignored_path:\n                if self.verbose:\n                    print(f\"Ignoring path: {path}\")\n                return True\n        \n        return False\n    \n    def get_file_info(self, file_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        Get information about a file including its contents.\n        \n        Args:\n            file_path: Path to the file\n            \n        Returns:\n            Dictionary containing file information and contents\n        \"\"\"\n        try:\n            stat = file_path.stat()\n            file_info = {\n                'name': file_path.name,\n                'type': 'file',\n                'size': stat.st_size,\n                'modified': datetime.fromtimestamp(stat.st_mtime).isoformat(),\n                'extension': file_path.suffix.lower() if file_path.suffix else None\n            }\n            \n            # Check if we should capture contents based on config\n            if self._should_capture_contents(file_path):\n                file_info['contents'] = self._get_file_contents(file_path)\n            \n            return file_info\n            \n        except (OSError, IOError) as e:\n            if self.verbose:\n                print(f\"Warning: Could not get info for file {file_path}: {e}\")\n            return {\n                'name': file_path.name,\n                'type': 'file',\n                'error': str(e)\n            }\n    \n    def scan_directory(self, root_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        Scan a directory and return its structure as a dictionary.\n        \n        Args:\n            root_path: Root directory to scan\n            \n        Returns:\n            Dictionary representing the directory structure\n        \"\"\"\n        if self.verbose:\n            print(f\"Scanning: {root_path}\")\n        \n        # Reset stats\n        self.stats = {'directories': 0, 'files': 0, 'ignored': 0}\n        \n        result = {\n            'name': root_path.name if root_path.name else str(root_path),\n            'type': 'directory',\n            'path': str(root_path.absolute()),\n            'generated_at': datetime.now().isoformat(),\n            'contents': []\n        }\n        \n        try:\n            # Get all items in the directory\n            items = list(root_path.iterdir())\n            items.sort(key=lambda x: (x.is_file(), x.name.lower()))\n            \n            for item in items:\n                if self.should_ignore(item):\n                    self.stats['ignored'] += 1\n                    continue\n                \n                if item.is_file():\n                    self.stats['files'] += 1\n                    file_info = self.get_file_info(item)\n                    result['contents'].append(file_info)\n                \n                elif item.is_dir():\n                    self.stats['directories'] += 1\n                    # Recursively scan subdirectory\n                    subdir_data = self._scan_subdirectory(item)\n                    result['contents'].append(subdir_data)\n        \n        except PermissionError as e:\n            if self.verbose:\n                print(f\"Warning: Permission denied accessing {root_path}: {e}\")\n            result['error'] = f\"Permission denied: {e}\"\n        except Exception as e:\n            if self.verbose:\n                print(f\"Warning: Error scanning {root_path}: {e}\")\n            result['error'] = str(e)\n        \n        return result\n    \n    def _scan_subdirectory(self, dir_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        Scan a subdirectory recursively.\n        \n        Args:\n            dir_path: Directory path to scan\n            \n        Returns:\n            Dictionary representing the subdirectory structure\n        \"\"\"\n        if self.verbose:\n            print(f\"  Scanning subdirectory: {dir_path}\")\n        \n        result = {\n            'name': dir_path.name,\n            'type': 'directory',\n            'contents': []\n        }\n        \n        try:\n            items = list(dir_path.iterdir())\n            items.sort(key=lambda x: (x.is_file(), x.name.lower()))\n            \n            for item in items:\n                if self.should_ignore(item):\n                    self.stats['ignored'] += 1\n                    continue\n                \n                if item.is_file():\n                    self.stats['files'] += 1\n                    file_info = self.get_file_info(item)\n                    result['contents'].append(file_info)\n                \n                elif item.is_dir():\n                    self.stats['directories'] += 1\n                    # Recursively scan subdirectory\n                    subdir_data = self._scan_subdirectory(item)\n                    result['contents'].append(subdir_data)\n        \n        except PermissionError as e:\n            if self.verbose:\n                print(f\"Warning: Permission denied accessing {dir_path}: {e}\")\n            result['error'] = f\"Permission denied: {e}\"\n        except Exception as e:\n            if self.verbose:\n                print(f\"Warning: Error scanning {dir_path}: {e}\")\n            result['error'] = str(e)\n        \n        return result\n    \n    def save_to_json(self, data: Dict[str, Any], output_path: Path) -> None:\n        \"\"\"\n        Save the directory data to a JSON file.\n        \n        Args:\n            data: Directory data dictionary\n            output_path: Path to save the JSON file\n        \"\"\"\n        try:\n            with open(output_path, 'w', encoding='utf-8') as f:\n                json.dump(data, f, indent=2, ensure_ascii=False)\n        except Exception as e:\n            raise Exception(f\"Failed to save JSON file: {e}\")\n    \n    def get_stats(self) -> Dict[str, int]:\n        \"\"\"\n        Get statistics from the last scan operation.\n        \n        Returns:\n            Dictionary containing scan statistics\n        \"\"\"\n        return self.stats.copy()\n    \n    def _should_capture_contents(self, file_path: Path) -> bool:\n        \"\"\"\n        Check if file contents should be captured based on configuration.\n        \n        Args:\n            file_path: Path to the file\n            \n        Returns:\n            True if contents should be captured, False otherwise\n        \"\"\"\n        # Check if content capture is enabled\n        if not self.config.get('capture_contents', True):\n            return False\n        \n        # Check file size limit\n        max_size = self.config.get('max_content_size', 10 * 1024 * 1024)  # 10MB default\n        try:\n            if file_path.stat().st_size > max_size:\n                if self.verbose:\n                    print(f\"Skipping contents for large file: {file_path} ({file_path.stat().st_size} bytes)\")\n                return False\n        except (OSError, IOError):\n            return False\n        \n        # Check if extension is in capture list (if specified)\n        capture_extensions = self.config.get('capture_extensions', [])\n        if capture_extensions:\n            extension = file_path.suffix.lower()\n            if extension not in capture_extensions:\n                return False\n        \n        # Check if extension is in no-capture list\n        no_capture_extensions = self.config.get('no_capture_extensions', [])\n        if no_capture_extensions:\n            extension = file_path.suffix.lower()\n            if extension in no_capture_extensions:\n                return False\n        \n        return True\n    \n    def _get_file_contents(self, file_path: Path) -> Dict[str, Any]:\n        \"\"\"\n        Get file contents, handling both text and binary files.\n        \n        Args:\n            file_path: Path to the file\n            \n        Returns:\n            Dictionary containing content data\n        \"\"\"\n        try:\n            # Try to read as text first\n            try:\n                with open(file_path, 'r', encoding='utf-8') as f:\n                    content = f.read()\n                return {\n                    'type': 'text',\n                    'encoding': 'utf-8',\n                    'data': content\n                }\n            except UnicodeDecodeError:\n                # Try other common encodings\n                for encoding in ['latin-1', 'cp1252', 'iso-8859-1']:\n                    try:\n                        with open(file_path, 'r', encoding=encoding) as f:\n                            content = f.read()\n                        return {\n                            'type': 'text',\n                            'encoding': encoding,\n                            'data': content\n                        }\n                    except UnicodeDecodeError:\n                        continue\n                \n                # If all text encodings fail, treat as binary\n                with open(file_path, 'rb') as f:\n                    binary_content = f.read()\n                encoded_content = base64.b64encode(binary_content).decode('ascii')\n                return {\n                    'type': 'binary',\n                    'encoding': 'base64',\n                    'data': encoded_content\n                }\n                \n        except Exception as e:\n            if self.verbose:\n                print(f\"Warning: Could not read contents of {file_path}: {e}\")\n            return {\n                'type': 'error',\n                'error': str(e)\n            }"
      }
    },
    {
      "name": "main.py",
      "type": "file",
      "size": 4244,
      "modified": "2025-10-06T08:08:21.172832",
      "extension": ".py",
      "contents": {
        "type": "text",
        "encoding": "utf-8",
        "data": "#!/usr/bin/env python3\n\"\"\"\nDirectory Packager - Console Application\nGenerates packaged JSON files from directory structures with configurable ignore patterns.\n\"\"\"\n\nimport argparse\nimport json\nimport sys\nfrom pathlib import Path\nfrom typing import Optional\nfrom datetime import datetime\n\nfrom directory_packager import DirectoryPackager\nfrom config_manager import ConfigManager\n\n\ndef main():\n    \"\"\"Main entry point for the directory packager application.\"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"Generate a packaged JSON file from a directory structure\"\n    )\n    parser.add_argument(\n        \"root_directory\",\n        type=str,\n        help=\"Root directory to scan and package\"\n    )\n    parser.add_argument(\n        \"-o\", \"--output\",\n        type=str,\n        default=None,\n        help=\"Output JSON file path (default: outputs/<foldername>_<datetime>.json)\"\n    )\n    parser.add_argument(\n        \"-c\", \"--config\",\n        type=str,\n        default=\"config.json\",\n        help=\"Configuration file path (default: config.json)\"\n    )\n    parser.add_argument(\n        \"-v\", \"--verbose\",\n        action=\"store_true\",\n        help=\"Enable verbose output\"\n    )\n\n    args = parser.parse_args()\n\n    try:\n        # Validate root directory\n        root_path = Path(args.root_directory)\n        if not root_path.exists():\n            print(f\"Error: Root directory '{args.root_directory}' does not exist.\")\n            sys.exit(1)\n        \n        if not root_path.is_dir():\n            print(f\"Error: '{args.root_directory}' is not a directory.\")\n            sys.exit(1)\n\n        # Load configuration\n        config_manager = ConfigManager(args.config)\n        config = config_manager.load_config()\n        \n        if args.verbose:\n            print(f\"Using configuration: {args.config}\")\n            print(f\"Scanning directory: {root_path.absolute()}\")\n\n        # Create packager and generate JSON\n        packager = DirectoryPackager(config, verbose=args.verbose)\n        directory_data = packager.scan_directory(root_path)\n\n        # Save to output file in outputs directory\n        outputs_dir = Path(\"outputs\")\n        outputs_dir.mkdir(exist_ok=True)\n        \n        # Generate filename if not provided\n        if args.output is None:\n            # Get folder name and clean it for filename use\n            if root_path.name:\n                folder_name = root_path.name\n            else:\n                # For current directory, get the actual folder name\n                folder_name = root_path.resolve().name\n            \n            # Replace invalid filename characters\n            folder_name = \"\".join(c for c in folder_name if c.isalnum() or c in ('-', '_', '.')).strip()\n            if not folder_name:\n                folder_name = \"directory\"\n            \n            # Generate timestamp\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            filename = f\"{folder_name}_{timestamp}.json\"\n            output_path = outputs_dir / filename\n        else:\n            # If user provided just a filename, put it in outputs folder\n            # If user provided a full path, respect their choice\n            output_path = Path(args.output)\n            if not output_path.is_absolute() and len(output_path.parts) == 1:\n                output_path = outputs_dir / output_path\n        \n        packager.save_to_json(directory_data, output_path)\n\n        print(f\"Successfully generated packaged JSON: {output_path.absolute()}\")\n        \n        if args.verbose:\n            stats = packager.get_stats()\n            print(f\"Statistics:\")\n            print(f\"  - Total directories: {stats['directories']}\")\n            print(f\"  - Total files: {stats['files']}\")\n            print(f\"  - Ignored items: {stats['ignored']}\")\n\n    except FileNotFoundError as e:\n        print(f\"Error: Configuration file not found - {e}\")\n        sys.exit(1)\n    except json.JSONDecodeError as e:\n        print(f\"Error: Invalid JSON in configuration file - {e}\")\n        sys.exit(1)\n    except Exception as e:\n        print(f\"Error: {e}\")\n        sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    main()"
      }
    }
  ]
}